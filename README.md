# 한달 요약 😆
![제목_없는_아트워크 33](https://github.com/pakxe/javascript-christmas-6-pakxe/assets/64801796/18aa452c-3db4-4d72-89d5-78ee21bff2df)

<br/>
<br/>

# 실행 결과
<img width="872" alt="image" src="https://github.com/pakxe/javascript-christmas-6-pakxe/assets/64801796/15d24698-c625-4b23-91de-60b2dc2ad36d">

<br/>
<br/>

# 구현 특징
-----
# [ 착각하기 쉬운 값들 ]

카테고리 이름이나 요일의 숫자값(ex 일요일 = 0)은 실수가 나기 쉬운 부분이므로 이들을 상수화해 혼동없이 빠르게 사용할 수 있도록 했다.

```jsx
export const CATEGORY = deepFreeze({
  appetizer: 'appetizer',
  mainCourse: 'mainCourse',
  dessert: 'dessert',
  beverage: 'beverage',
});
```

```jsx
// 일주일
const DAYS_OF_WEEK = deepFreeze({
  sun: 0,
  mon: 1,
  tue: 2,
  wed: 3,
  thu: 4,
  fri: 5,
  sat: 6,
});

// 평일
const WEEKDAYS = deepFreeze([
  DAYS_OF_WEEK.sun,
  DAYS_OF_WEEK.mon,
  DAYS_OF_WEEK.tue,
  DAYS_OF_WEEK.wed,
  DAYS_OF_WEEK.thu,
]);

// 주말
const WEEKEND = deepFreeze([DAYS_OF_WEEK.fri, DAYS_OF_WEEK.sat]);
```

또한 보통의 이벤트 시작과 종료 시간은 00:00 ~ 23:59이므로 이 시간도 상수로 구분해두었다.

```jsx
const TIME = deepFreeze({
  start: 'T00:00:00.000Z',
  end: 'T23:59:59.000Z', // 보통의 이벤트 종료 시간
});
```

<br/>
<br/>

# [ 메서드 오버라이딩 ]

이번 미션은 여러 개의 이벤트가 존재한다. 그리고 이 이벤트엔 이름과 기간, 할인 액수가 모두 필요했다. 따라서 이들을 `Event` 라는 부모 클래스를 만들어 선언해 다른 이벤트 클래스에선 위 항목들을 구현할 필요가 없도록 했다.

```jsx
class Event {
  #name;

  #period; // { start: Date{} , end: Date {} }

  
  // 각자의 날짜 검증이 다를 수 있으므로 오버라이딩해서 구현하도록 함
  isWithinEventDays() {
    throw new OverridingError();
  }

  // 이벤트 플래너가 사용하기 쉽도록 혜택 금액 반환 메서드는 통일
  get totalDiscountPrice() {
    throw new OverridingError();
  }

	...
}

class SpecialEvent extends Event { ... }
```

위에 `OverridingError` 를 던지는 메서드가 있는데 이는 반드시 이 Event 클래스를 상속한 클래스 안에서 이를 오버라이딩 하지 않으면 안된다는 의미로 오류를 넣었다. 

```js
class OverridingError extends CustomError {
  constructor() {
    super('메서드를 오버라이딩 해주세요.');
  }
}
```

<br/>
<br/>

## 이벤트 플래너는 모든 이벤트를 다룬다.

왜냐하면 내가 설계한 이벤트 플래너는 `이벤트 리스트를 순회` → `해당하는 이벤트 인스턴스 생성` → `이벤트 인스턴스에서 이름과 할인 액수를 가져오기` 흐름으로 진행되기 때문이다. 이때 `이벤트 인스턴스에서 이름과 할인 액수를 가져오기` 를 각 이벤트 클래스에서 다른 메서드로 구현해버린다면 **이벤트 마다 다른 메서드를 사용**해서 결과를 가져와야했고, 이는 이벤트 플래너 내부의 **코드 양의 증가**로 이어지게 된다.

나는 이벤트가 몇십 개로 늘어났을 상황을 생각해서 이벤트의 개성(독자적인 메서드들)을 줄이고 싶었고, 이는 메서드명의 일치로 구현할 수 있었다. 이벤트 플래너가 이벤트 목록을 가지고 있고, 이 이벤트 목록을 순회하면서 `.name`, `.price` 처럼 동일한 메서드로 값에 접근하면 반복 형태이기 때문에 간단했다.

모든 이벤트는 Event 클래스를 상속받으므로 이 안에 이벤트 플래너가 사용할 메서드를 선언해둔다. 그리고 이 메서드를 각 이벤트 클래스들이 오버라이딩해 구현한다.

<img width="211" alt="image" src="https://github.com/pakxe/javascript-christmas-6-pakxe/assets/64801796/05026737-bbad-4c1e-8d92-c0f7d4ca2ae1">
[ Event1.js ] Event를 상속받은 이벤트1

<img width="364" alt="image" src="https://github.com/pakxe/javascript-christmas-6-pakxe/assets/64801796/3de8e059-f465-4bab-9120-fb548fa04256">
[ Event2.js ] Event를 상속받은 이벤트 2
같은 `isWithinEventDays` 여도 구현이 다른 모습이다

<img width="621" alt="image" src="https://github.com/pakxe/javascript-christmas-6-pakxe/assets/64801796/7ec5057c-1271-47a2-ab92-beedf8035a75">
[ EventPlanner.js ] 이벤트 플래너

<br/>
<br/>

## 오류 추적 시간 줄이기

물론 굳이 에러를 던지지 않고 같은 메서드명으로 작성해도 되지만, 만약 이 프로젝트에 새로운 개발자가 들어오면 **이벤트 플래너가 사용해야하는 메서드**를 모를 수 있기 때문이다. 결국 그렇게되면 **어딘가에서 문제가 발생**하고 에러 트래킹에 많은 시간이 소요될 수 있으므로 사전에 이런 문제를 원천 차단하기 위해 오버라이딩에러를 만들어 사용하게 되었다.

<br/>
<br/>

# [ 상품을 주는 이벤트와 아닌 이벤트 ]

요구사항에서 제시하는 이벤트는 상품을 주는 이벤트와 주지 않는 이벤트로 나눌 수 있었다. 따라서 상품을 주는 이벤트는 `GiftEvent`라는 클래스를 **상속**하게해 할인이 적용된 이벤트 목록에서 상품을 주는 이벤트만 따로 추출하는 것이 가능하게 되었다. 결과적으로 증정하는 상품 목록만을 깔끔하게 뽑아낼 수 있었다.

```js
  #getGiftEventList() {
    return this.#eventList.filter((event) => event instanceof GiftEvent);
  }
```

<br/>
<br/>


# [ 상태를 갖고 있는 객체가 일을 하도록 하기 ]

이 부분에서 많은 고민을 했다. 

나는 방문 날짜를 js의 Date 클래스를 사용해 다루기로 했고, 1 ~ 31일 사이의 값으로 유효성 검증을 해야했기에 이를 `CustomDate` 라는 클래스를 만들어 수행하게 했다. 

다만 이 날짜에 대해서 다른 이벤트들이 정보를 얻어야 할 때가 많았다. 예를들어 크리스마스 이벤트는 방문 날짜와 12월 1일 사이 며칠이 차이가 나는지에 대한 정보가 필요하다. 

그렇다면 이 차이값을 구할 수 있는 방법은 크게 3가지로 생각되었다.

1. 크리스마스는 `방문 날짜` 객체의 날짜를 가져와서 자신 안에서 차이를 계산
2. 방문 날짜 객체에게 12월 1일을 전달하고 차이를 달라고 하기
3. 날짜 유틸 함수를 만들어서 이곳에서 따로 수행
   
<br/>
<br/>

## 누구를 위한 메서드인가

**1번** 방법의 경우 결국 크리스마스 이벤트만을 위한 메서드가 `CustomDate` 에 쓰이게 되는 격이다. **사용하는건 크리스마스 이벤트인데, 이것이 구현된 곳은 CustomDate이다 보니까 경계가 모호**해지는 느낌이 있었다. 특히나 이 `차이를 구하는` 메서드가 크리스마스 이벤트에서만 쓰이다보니 더 이런 느낌을 받았던 것 같다.

그러나 새로운 이벤트가 생겨 이 차이를 구하는 메서드를 사용할 일이 생긴다면 그때는 CustomDate에 넣어도 될 것 같다는 생각이 들었다. 각 이벤트에서 차이를 구하는 코드가 중복되지 않게 하기 위함이다.

<br/>
<br/>

## 비슷한 성격의 메서드들을 모아둘까?

다만 **날짜와 관련**해서 년도와 월을 주면 이 달의 마지막 날짜를 반환하는 함수가 다른 곳에서 필요한 일이 생겼고, 그렇다면 이 함수랑 위에서 말한 차이를 구하는 로직을 함께 두면 **날짜와 관련되었다는 성격**이 비슷해서 보기 좋겠다는 생각을 해 **3번** 방법인 `DateUtils` 라는 클래스에 이들을 모두 몰아넣게 되었다. 차이를 구하는 메서드 외에도 다른 이벤트에서 필요한 같은 날짜인지, 요일 검증 과 같은 메서드(비슷한 성격)도 함께 넣게 되었다.

다만 이렇게 되니 메서드의 인자가 하나씩 더 늘어나게 되었다. 그리고 외부 클래스에서 CustomDate에서 갖고있는 값인 날것의 날짜(new Date(…)로 생성된 인스턴스)에 접근해야했기 때문에 getter(get day)가 필요했다.

<img width="286" alt="image" src="https://github.com/pakxe/javascript-christmas-6-pakxe/assets/64801796/64795719-6d1a-41b9-9da5-4658f46f2adc">
[DataUtils.js] (비슷한 메서드들이기 때문에 하나만 캡처하였습니다.)

<img width="283" alt="image" src="https://github.com/pakxe/javascript-christmas-6-pakxe/assets/64801796/603247e0-e150-4028-8ec6-429b303ca2a4">
[ CustomDate.js ] 요일을 받아오는 getter

<br/>
<br/>

## 모아두니 부작용 발생

그런데 이 메서드들을 `CustomDate` 에 작성했더라면 date라는 인자가 없어도 된다. 또한 이 유틸들을 사용하는 클래스에서 `DateUtils` 를 모두 import하는 것은 번거롭다고 느꼈다. `CustomDate` 에 아래 메서드들을 두었다면 굳이 import하지 않아도 값을 구할 수 있었기 때문이다. 그리고 getter도 줄일 수 있었다.

또한 js에서 제공하는 객체, 배열같은 자료형들은 다양한 유틸 메서드들을 갖고 있다는 점에서 이사 결심을 확신하게 되었다. 처음에 한 고민인 **크리스마스 이벤트만을 위한 메서드를 크리스마스 이벤트가 아닌 곳에 작성해도 되는가**는 결국 미래의 요구사항은 어떻게 될지 모르고, `최대한 예상해서 코드의 변경이 적은 쪽`으로 설계를 해야한다는 결론으로 향했다. 차이를 구하는 메서드는 크리스마스 뿐만이 아닌 다른 곳에서도 충분히 사용 가능성이 높았기때문이다. 따라서 메서드들을 `CustomDate`로 옮겼다. **2번** 방법이 최종 설계가 되었다.

<img width="420" alt="image" src="https://github.com/pakxe/javascript-christmas-6-pakxe/assets/64801796/207330f8-3eab-4caf-8898-1a154a103d24">
[ CustomDate.js ] 메서드 이사 후 인자가 줄어들었고, getter를 사용하지 않는 모습

<br/>
<br/>

## 이사하고 느꼈던 좋은 점들

이렇게 수정하니 **인자가 하나 줄어들어** 더 보기 좋아졌다. 그리고 anotherDate같은 **모호한 의미의 네이밍**을 사용하지 않을 수 있게 됐다. **불필요한 getter**도 하나 줄일 수 있었다. 

물론 이것이 절대적으로 옳은 답은 아닐 수 있지만, 현재 요구사항(getter 줄이기, 객체가 일을 하게하기)수행 면에서는 이전 설계보다는 만족한 것 같다.

<br/>
<br/>

## 이사 과정에서의 어려움

다만 수정하는 과정에서 이 메서드를 사용하는 곳을 **일일히 찾아 수정**해야해 이 부분이 굉장히 골치아팠다. 처음부터 잘 짜면 좋겠지만, 문제를 100% 예측하는 것은 불가능하고 세상이 변하면서 요구사항도 바뀔 수 있으므로 이런 수정에 들어가는 비용을 어떻게 줄일 수 있을지 생각해봐야 겠음을 느꼈다.

다만 수정을 최소화하면서 고치는 과정이 오히려 더 복잡한 설계가 될 수도 있을 것 같다. 

개발자에게 있어 시간은 정말 중요한 자원이라고 들어왔는데, 이 시간을 줄이기 위해 시간을 써서 설계를 고민해야했다. 그런데 지금 내가 시간을 써서 3가지 방법에 대해 생각해보고 각자의 장단점을 고려해보고서도 이런 수정이 발생하게 되었다. 결국 기초 지식과 설계를 탄탄히해 최대한 수정을 적게 하는 설계의 성공 **가능성을 높여야**겠다고 생각이 들었다..

<br/>
<br/>

# [ 주문 히스토리 ]

이벤트 목표의 3번인 `12월 이벤트 참여 고객의 5%가 내년 1월 새해 이벤트에 재참여하는 것` 과 `배지를 2024 새해 이벤트에서 활용` 이 두가지를 만족시키기 위해 주문 히스토리를 구현하기로 했다. 주문 정보를 기록해두어야 몇 %가 새해 이벤트에 참여하는지 알 수 있기 때문이다.

다만 고객이 아닌 `주문` 히스토리인 이유는 **고객들의 id는 입력 받지 않으므로 고객 식별이 안되기** 때문이다. 따라서 **주문마다 랜덤한 주문 번호를 생성해 주문 번호로 배지를 찾고 새해 이벤트에서 활용**하는 방식으로 하기로 했다.

또한 쇼핑몰에서 비회원으로 물건 구매시 주문 번호가 발행되고, 추후 내가 구매한 물건에 대한 정보를 보려면 이 주문 번호를 입력하는 방식으로 확인할 수 있기 때문에 이런 방식을 택하게 되었다. 고객에게 친숙한 방식이라고 생각되었기 때문이다. 물론 주문 번호 자체를 기억하는 것은 고객 입장에서 굉장히 귀찮은 일이지만 지금 상황(id가 없는)에선 최선이라고 판단했다.

<br/>
<br/>

## 주문 번호 생성하기

새해 이벤트를 위해 고객 또는 관리자는 내년 새해에 고객의 배지에 맞는 상품을 찾아야한다. 이때 식별은 주문 번호로 하기로 했다. 주문 번호를 key로, 정보(배지 등)를 value로 하는게 제일 직관적이라고 생각해 Map 자료구조를 사용했다.

그리고 제일 빠르게 구현할 수 있는 랜덤 번호를 생성하는 방식으로 주문 번호를 대체하기로 했다. 따라서 자리수를 주면 랜덤하게 숫자 개수만큼 반환해주는 함수를 만들어 사용하였다.

```jsx
const generateRandomNumber = (length) => {
  const numberLength = `1e${length}`;
  const randomNumber = Math.floor(Math.random() * numberLength);

  return randomNumber;
};
```

지금은 주민번호와 같은 13자리의 주문 번호를 사용하기로 했다. 겹칠 가능성이 적고 빠르게 생성되기 때문이다. 

그리고 이렇게 생성된 주문 번호가 정말 낮은 확률이지만 똑같은 값이 생성될 수 있기 때문에 map에 set하기 전에 해당 주문 번호가 이미 map에 있는지 확인하고 값을 추가했다.

```jsx
do {
   orderId = generateRandomNumber(ORDER_ID_LENGTH);
} while (this.#customerHistoryList.has(orderId)); // 이미 존재한다면 다시 generate

return orderId;
```

<br/>
<br/>

## 고객 정보 저장하기

**어떤 정보가 어떻게 활용될지 아무런 힌트(문제 메일)가 없었기**에 입력받았던 모든 정보인 방문일, 구매 목록과 결과인 배지를 함께 저장하기로 했다. 만약 배지만 두었다면 추후 다른 사항도 저장했었어야 한다는 식으로 요구가 들어올 때 변경사항이 많아질 수 있다는 단점도 있다.

```jsx
add({ visitDate, menuList, badge }) {
		// 랜덤한 주문번호 만들기
    const orderId = this.#generateOrderId();

    this.#customerHistoryList.set(orderId, { visitDate, menuList, badge });

	  // ...
}
```

<br/>
<br/>

## 배지 찾기

map에 저장했으니 당연하게 orderId로 get을 받아올 수 있다. 따라서 이 방법으로 정보를 꺼내와 반환하는 식으로 구현했다.

이때 새해 이벤트 상품을 받기 위해 랜덤하게 모든 orderId값을 입력하는 `악성(?)` 고객이 있을 수 있으므로 5회 까지만 orderId입력을 받는 것으로 제한했다. 

<img width="681" alt="image" src="https://github.com/pakxe/javascript-christmas-6-pakxe/assets/64801796/f5b9808f-c507-49f6-b652-e2fd4016af32">


이때 try, catch를 사용해서 구현했는데 횟수를 어떻게 제한할까 생각하다, 5회를 넘으면 ExitError를 던졌고 아직 기회가 남아있다면 RetryError를 던졌다. 이게 최선의 구조는 아닐 것 같은데, 일단 try,catch에서 잡을 수 있는건 에러고 그 에러로 종료할지 말지를 선택해야했기에 이런 방식을 택하게 되었다.

<img width="626" alt="image" src="https://github.com/pakxe/javascript-christmas-6-pakxe/assets/64801796/1882c587-1a24-4fbb-aa3b-421c7a32ae38">

오류의 타입은 instanceOf로 파악해 조건을 분기하였다.

정상 동작은 아래와 같다. 배지 다음으로 주문번호를 출력하고, 해당 주문 번호를 기억해두었다가 입력하는 방식이다.

<img width="634" alt="image" src="https://github.com/pakxe/javascript-christmas-6-pakxe/assets/64801796/ed2d6c61-ec81-4bbd-aced-e668aea76a3f">

그리고 이렇게 찾아진 배지는 `isProductReceived`값을 true로 바꿔 이미 수령된 상태로 바꾼다.
만약 해당 orderId로 다시 배지 찾기가 수행된다면 '이미 수령된 상품입니다.'라고 에러를 띄워 추가 수령을 막는다.

그리고 새해 이벤트 참여율이 5%가 넘어야 하므로, 이를 측정하기 위한 참여율 계산 로직을 추가로 구현하였다. 

<br/>
<br/>

## 구현하면서 겪었던 어려움

이벤트 기간, 이벤트 플래너의 자동화로 확장을 많이 고려했다고 생각했었는데 이렇게 2024년으로 년도가 다른 이벤트와 주문 정보의 저장이 추가되어 코드에 변화가 많이 있었다. 특히나 이벤트 플래너의 자동화가 새로운 인자인 배지를 받아야했기 때문에 기존의 인자 전달 방식을 수정해야했다.

따라서 이는 구조 분해 할당으로 해결했다. 이벤트 플래너에 이벤트가 필요한 인자들(방문일, 구매목록, 배지.)들을 하나의 객체로 담아서 넘겨주고 각 이벤트에서 필요한 인자를 `({ visitDate })` 로 가져와 사용하는 방식이다. 다만 이건 억지로 배지를 위해 확장했었어야 해서 이렇게 확장한거라 만약 100개가 되는 인자가 필요하게 된다면 아마 지금의 설계를 수정해야 할 것 같다.. 모든 이벤트에 100개의 인자가 가는 것이기 때문이다. 더 나은 방향의 수정이 있을 것 같다.

그리고 날짜를 다루는 것이 많이 어려웠다. 방문일은 유효성 검사와 비교 메서드들을 위해 CustomDate라는 클래스를 따로 만들어 사용했는데, 이벤트의 기간은 굳이 CustomDate를 사용하지 않아도 충분했다. 따라서 js에서 기본으로 제공하는 Date클래스를 사용했는데 여기서 혼란이 생겼다. 결국 `날짜` 라는 개념은 동일한데 각각의 클래스가 다른 클래스이다보니 어떤게 어떤 클래스를 어떻게 사용하는지 빠르게 알기 어려웠다. 모두를 CustomDate로 통일한다면 값 자체를 반환하는 getter를 만들어야 했다. 그래야 CustomDate끼리 비교할 수 있기 때문이다. 이거까진 굳이 싶어 이벤트 기간은 Date, 방문일은 CustomDate로 계속 남겨두게 되었다. 더 최선이 있었을 것 같아 아쉽다. 

<br/>
<br/>

# [ 신경 썼던 점 ]

## 확장성 고려

- 메뉴에 맛이나 옵션이 추가될 수 있음 
→ sol) map으로 {메뉴이름: 가격} 쌍이 아닌 {메뉴이름, 가격, 옵션}처럼이 가능하도록 **객체**로 다루기
- 만약 2023원보다 싼 디저트가 있다면 
→ sol) 그 디저트 **가격 만큼만 할인**한다. (100원이라면 2023원 할인이 아닌 100원만 할인)
- `고객 입장에서 중복 할인` 이라는건 증정 이벤트에서 24만원에 다른 샴페인을 더 준다면 기존 샴페인 + 다른 샴페인 이런 식일 수 있다(누적 증정)
→ sol) 증정 이벤트의 **상품 목록을 배열로** 만들어 다룬다.
- 또는 12만원마다 샴페인이 누적될 수 있다(count가 필요)
→ sol) 증정 상품 목록에 **count필드**를 넣는다.
- 카테고리별로 메뉴를 출력해야할 수도 있다(배민도 주메뉴, 사이드 이런식으로 정렬해둔 것 같습니다)
→ sol) 모든 메뉴에 **카테고리 필드**를 넣는다.
- 새로운 이벤트 추가(2023.12월에만 한정되지 않아야함)
→ sol) **기간을 Date객체**로 사용한다.
- 이벤트가 추가되도 코드의 변경이 적어야함(100개의 이벤트가 새로 생긴다면?)
→ sol) **팩토리 메서드 패턴, 이벤트 상속, 똑같은 메서드명, 반드시 오버라이딩**해야하는 항목 고려
- 다른나라에서 쓴다면?(원 → 달러 이런 식으로 바꿔야함)
→ sol) **가능한 모든 텍스트**는 **상수**로 떼어놓기
- 최소 주문 개수가 아닌 최소 메뉴 개수가 생긴다면?(1인 1메뉴처럼)
→ sol) **메뉴 개수도 상수**로 분리
- 이벤트에 필요한 인자가 추가됨
→ sol) **구조 분해 할당**으로 필요한 인자만 추출해 사용

등의 사항을 구현하면서 고려하려고 노력했다. 다만 이런 부분을 오래 고민하다보니 정작 구현도 그만큼 지체되어 어느 정도 까지만 생각해야겠음을 느꼈다.

<br/>
<br/>

# [ 아쉬운 점 ]

## 멤버 변수가 많았던 이벤트 플래너

이벤트 플래너는 `이벤트 리스트를 순회` → `해당하는 이벤트 인스턴스 생성` → `이벤트 인스턴스에서 이름과 할인 액수를 가져오기` 의 역할을 수행하도록 설계하려고 했다. 이것이 결코 많은 역할이라고 처음에는 생각하지 못했기에 위 계획 그대로 구현했다.그런데 이 이벤트 플래너가 할인 리스트와 증정 리스트를 모두 갖고있으니 `할인 금액`을 계산해야했고, 할인 금액을 알고 있으니 `할인을 뺀 최종 금액`도 계산해야했다. 

그리고 이런 금액을 구하는 과정이 오래걸릴 수 있기 때문에 생성자에서 미리 1번만 진행해야했고, 결국 이 할인 금핵과 할인을 뺀 최종 금액이 이벤트 플래너의 멤버 변수로서 들어가게 되었다.

분리를 어떻게 해야할지 고민해보았는데 DiscountList, GiftList로 나눠서 둘을 분리할 수 있었다. 하지만 메서드를 잘게 나누는 것은 이해해도 클래스를 굳이 하위 단위도 아닌 옆으로 쪼개는 느낌이 들어 쉽게 납득이 가지 않았다(아닐 수도 있다..) 다만 내가 디렉터리 구조를 잘 준비하지 않아서 그런지 이미 파일이 너무 많아 파악이 어려웠고 이 상황에서 파일 2개를 더 늘린다는 것은 어려운 선택이었다. 디렉터리 구조는 물론이고 ‘각 클래스 마다 한 줄로 역할을 설명할 수 있어야 한다’ 라는 생각을 갖게 되었다. 지금의 이벤트 플래너는 한 줄로 설명하기엔 너무 많은 일을 하는 것 같았기 때문이다. 또한 객체 지향 설계에 대해서 많이 부족함도 느꼈다. 무엇을 어떤 기준으로 어느 타이밍에 분리해야하는지 개념적인 지식이 없어 그냥 ‘현실 세계에선 이렇게 하겠지’ 하는 짧은 생각으로 객체를 나누었기에 이런 상황이 벌어진 것 같다. 아쉽다.

<br/>
<br/>

## 의존성 주입

지난 프리코스에서 의존성 주입 방식을 통해 쉽게 갈아끼울 수 있는 게임을 만들었었다. 그런데 지금은 구현에만 많이 시간을 쓰다보니 다른 곳에 신경쓸 여유가 부족해 여기저기 구멍이 나있는 것 같단 느낌을 받았다. 또한 주문 히스토리와 이를 서치하는 과정까지 구현하다보니 더 촉박했다. 3주차까지의 미션은 구현해야할 것들이 이번 미션많큼 크지 않았기 때문에 미션 자체에 대해서 모든 것을 위에서 한번에 내려다보는 것이 가능했다. 하지만 이번 미션은 한눈에 다 담기지 않는 것처럼 하나에 집중하면 하나를 놓치고 있을 수 있다는 생각을 했다. 

모든 데이터가 한쪽 끝에서 다른 쪽 끝까지 이동해야했기에 그 모든 과정에서 생길 수 있는 변화에 대해서 고려하다보니 더 많이 어렵게 느껴진 것 같다. 그러다보니 의존성 주입이나 DRY원칙같은 것들을 놓치게 됐다..

<br/>
<br/>

## 많아진 파일들
고려한 것이 많다보니 파일이 엄청 많아지게 되었다. 일단 디렉터리에 넣어두면 정리가 되었다고 생각해서 이런 사태(?)가 벌어진 것 같다.
너무 세세하게 분리한 것 같기도 해서 무엇이 어떤 책임을 가지는지 명확히 정리해야할 필요를 느꼈다.

<br/>
<br/>

# flow
![Group 7](https://github.com/pakxe/javascript-christmas-6-pakxe/assets/64801796/88b6abfd-fdd0-4756-a885-d89f287949c4)

<br/>
<br/>

# 미션 - 크리스마스 프로모션

## 🔍 진행 방식

- 미션은 **기능 요구 사항, 프로그래밍 요구 사항, 과제 진행 요구 사항** 세 가지로 구성되어 있다.
- 세 개의 요구 사항을 만족하기 위해 노력한다. 특히 기능을 구현하기 전에 기능 목록을 만들고, 기능 단위로 커밋 하는 방식으로 진행한다.
- 기능 요구 사항에 기재되지 않은 내용은 스스로 판단하여 구현한다.

## 📮 미션 제출 방법

- 미션 구현을 완료한 후 GitHub을 통해 제출해야 한다.
  - GitHub을 활용한 제출 방법은 [프리코스 과제 제출](https://docs.google.com/document/d/1cmg0VpPkuvdaetxwp4hnyyFC_G-1f2Gr8nIDYIWcKC8/edit?usp=sharing) 문서를 참고해
    제출한다.
- GitHub에 미션을 제출한 후 [우아한테크코스 지원](https://apply.techcourse.co.kr) 사이트에 접속하여 프리코스 과제를 제출한다.
  - 자세한 방법은 [제출 가이드](https://github.com/woowacourse/woowacourse-docs/tree/master/precourse#제출-가이드) 참고
    - **지원 플랫폼을 통해 과제를 제출하지 않으면 최종 제출되지 않은 것으로 처리되므로 주의한다.**

## 🚨 과제 제출 전 체크 리스트 - 0점 방지

- 기능 구현을 모두 정상적으로 했더라도 **요구 사항에 명시된 출력값 형식을 지키지 않을 경우 0점으로 처리**한다.
- 기능 구현을 완료한 뒤 아래 가이드에 따라 테스트를 실행했을 때 모든 테스트가 성공하는지 확인한다.
- **테스트가 실패할 경우 0점으로 처리**되므로, 반드시 확인 후 제출한다.

### 테스트 실행 가이드

- 테스트 패키지 설치를 위해 `Node.js` 버전 `18.17.1` 이상이 필요하다.
- 다음 명령어를 입력해 패키지를 설치한다.

```bash
npm install
```

- 설치가 완료되었다면, 다음 명령어를 입력해 테스트를 실행한다.

```bash
npm test
```

---

## 🚀 기능 요구 사항

> 이번 미션은 이메일 형식의 기능 요구 사항입니다. 문제를 구현하는 데 필요한 요구사항과 배경지식은 이메일 내용에 전부 담겨있으니, 꼼꼼하게 확인하고 필요하다면 주어진 문제의 내용을 통해 유추하고 스스로 판단해
> 구현해 주시면 됩니다. 문제의 모든 내용은 충분히 검토되었으며, 출제 의도를 담은 내용임을 알려드립니다.

보낸 사람: 비즈니스팀 \<`biz@woowacourse.io`\>  
받는 사람: 개발팀 \<`dev@woowacourse.io`\>

제목: 12월 이벤트를 위한 개발 요청

안녕하세요. 비즈니스팀입니다!

다가오는 2023년 12월에 우테코 식당에서 1년 중 제일 큰 이벤트를 개최하려고 합니다.  
12월을 위해 이벤트 예산을 넉넉히 확보해 두었으니, 예산은 걱정하지 마세요~

특별히 이번 12월 이벤트를 진행하기 위해서, 개발팀의 도움이 많이 필요합니다.  
아래 메뉴와 달력 이미지를 보면서 12월 이벤트 계획과 요청 내용을 본격적으로 설명해 드릴게요.

#### 메뉴

```
<애피타이저>
양송이수프(6,000), 타파스(5,500), 시저샐러드(8,000)

<메인>
티본스테이크(55,000), 바비큐립(54,000), 해산물파스타(35,000), 크리스마스파스타(25,000)

<디저트>
초코케이크(15,000), 아이스크림(5,000)

<음료>
제로콜라(3,000), 레드와인(60,000), 샴페인(25,000)
```

#### 달력

![](image.png)

#### 이벤트 목표

1. 중복된 할인과 증정을 허용해서, 고객들이 혜택을 많이 받는다는 것을 체감할 수 있게 하는 것
2. 올해 12월에 지난 5년 중 최고의 판매 금액을 달성
3. 12월 이벤트 참여 고객의 5%가 내년 1월 새해 이벤트에 재참여하는 것

#### 12월 이벤트 계획

- 크리스마스 디데이 할인
  - 이벤트 기간: 2023.12.1 ~ 2023.12.25
  - 1,000원으로 시작하여 크리스마스가 다가올수록 날마다 할인 금액이 100원씩 증가
  - 총주문 금액에서 해당 금액만큼 할인  
    (e.g. 시작일인 12월 1일에 1,000원, 2일에 1,100원, ..., 25일엔 3,400원 할인)
- 평일 할인(일요일~목요일): 평일에는 디저트 메뉴를 메뉴 1개당 2,023원 할인
- 주말 할인(금요일, 토요일): 주말에는 메인 메뉴를 메뉴 1개당 2,023원 할인
- 특별 할인: 이벤트 달력에 별이 있으면 총주문 금액에서 1,000원 할인
- 증정 이벤트: 할인 전 총주문 금액이 12만 원 이상일 때, 샴페인 1개 증정
- 이벤트 기간: '크리스마스 디데이 할인'을 제외한 다른 이벤트는 2023.12.1 ~ 2023.12.31 동안 적용

#### 혜택 금액에 따른 12월 이벤트 배지 부여

- 총혜택 금액에 따라 다른 이벤트 배지를 부여합니다. 이 배지는 2024 새해 이벤트에서 활용할 예정입니다.
  배지에 따라 새해 이벤트 참여 시, 각각 다른 새해 선물을 증정할 예정입니다.
  - 5천 원 이상: 별
  - 1만 원 이상: 트리
  - 2만 원 이상: 산타

#### 고객에게 안내할 이벤트 주의 사항

- 총주문 금액 10,000원 이상부터 이벤트가 적용됩니다.
- 음료만 주문 시, 주문할 수 없습니다.
- 메뉴는 한 번에 최대 20개까지만 주문할 수 있습니다.  
  (e.g. 시저샐러드-1, 티본스테이크-1, 크리스마스파스타-1, 제로콜라-3, 아이스크림-1의 총개수는 7개)

#### '12월 이벤트 플래너' 개발 요청 사항

- 고객들이 식당에 방문할 날짜와 메뉴를 미리 선택하면 이벤트 플래너가 주문 메뉴, 할인 전 총주문 금액, 증정 메뉴, 혜택 내역, 총혜택 금액, 할인 후 예상 결제 금액, 12월 이벤트 배지 내용을 보여주기를 기대합니다.
- 12월 중 식당 예상 방문 날짜는 언제인가요? (숫자만 입력해 주세요!)
  - 방문할 날짜는 1 이상 31 이하의 숫자로만 입력받아 주세요.
  - 1 이상 31 이하의 숫자가 아닌 경우, "[ERROR] 유효하지 않은 날짜입니다. 다시 입력해 주세요."라는 에러 메시지를 보여 주세요.
  - 모든 에러 메시지는 "[ERROR]"로 시작하도록 작성해 주세요.
- 주문하실 메뉴와 개수를 알려 주세요. (e.g. 해산물파스타-2,레드와인-1,초코케이크-1)
  - 고객이 메뉴판에 없는 메뉴를 입력하는 경우, "[ERROR] 유효하지 않은 주문입니다. 다시 입력해 주세요."라는 에러 메시지를 보여 주세요.
  - 메뉴의 개수는 1 이상의 숫자만 입력되도록 해주세요. 이외의 입력값은 "[ERROR] 유효하지 않은 주문입니다. 다시 입력해 주세요."라는 에러 메시지를 보여 주세요.
  - 메뉴 형식이 예시와 다른 경우, "[ERROR] 유효하지 않은 주문입니다. 다시 입력해 주세요."라는 에러 메시지를 보여 주세요.
  - 중복 메뉴를 입력한 경우(e.g. 시저샐러드-1,시저샐러드-1), "[ERROR] 유효하지 않은 주문입니다. 다시 입력해 주세요."라는 에러 메시지를 보여 주세요.
  - 모든 에러 메시지는 "[ERROR]"로 시작하도록 작성해 주세요.
- 주문 메뉴의 출력 순서는 자유롭게 출력해 주세요.
- 총혜택 금액에 따라 이벤트 배지의 이름을 다르게 보여 주세요.
- 총혜택 금액 = 할인 금액의 합계 + 증정 메뉴의 가격
- 할인 후 예상 결제 금액 = 할인 전 총주문 금액 - 할인 금액
- 증정 메뉴
  - 증정 이벤트에 해당하지 않는 경우, 증정 메뉴 "없음"으로 보여 주세요.
- 혜택 내역
  - 고객에게 적용된 이벤트 내역만 보여 주세요.
  - 적용된 이벤트가 하나도 없다면 혜택 내역 "없음"으로 보여 주세요.
  - 혜택 내역에 여러 개의 이벤트가 적용된 경우, 출력 순서는 자유롭게 출력해주세요.
- 이벤트 배지
  - 이벤트 배지가 부여되지 않는 경우, "없음"으로 보여 주세요.
- 적용된 이벤트가 하나도 없는 경우는 아래 예시를 참고해 주세요.

```
안녕하세요! 우테코 식당 12월 이벤트 플래너입니다.
12월 중 식당 예상 방문 날짜는 언제인가요? (숫자만 입력해 주세요!)
26 
주문하실 메뉴를 메뉴와 개수를 알려 주세요. (e.g. 해산물파스타-2,레드와인-1,초코케이크-1)
타파스-1,제로콜라-1 
12월 26일에 우테코 식당에서 받을 이벤트 혜택 미리 보기!
 
<주문 메뉴>
타파스 1개
제로콜라 1개

<할인 전 총주문 금액>
8,500원
 
<증정 메뉴>
없음
 
<혜택 내역>
없음
 
<총혜택 금액>
0원
 
<할인 후 예상 결제 금액>
8,500원
 
<12월 이벤트 배지>
없음
```

#### 기대하는 '12월 이벤트 플래너'의 예시 모습

```
안녕하세요! 우테코 식당 12월 이벤트 플래너입니다.
12월 중 식당 예상 방문 날짜는 언제인가요? (숫자만 입력해 주세요!)
3
주문하실 메뉴를 메뉴와 개수를 알려 주세요. (e.g. 해산물파스타-2,레드와인-1,초코케이크-1)
티본스테이크-1,바비큐립-1,초코케이크-2,제로콜라-1
12월 3일에 우테코 식당에서 받을 이벤트 혜택 미리 보기!
 
<주문 메뉴>
티본스테이크 1개
바비큐립 1개
초코케이크 2개
제로콜라 1개
 
<할인 전 총주문 금액>
142,000원
 
<증정 메뉴>
샴페인 1개
 
<혜택 내역>
크리스마스 디데이 할인: -1,200원
평일 할인: -4,046원
특별 할인: -1,000원
증정 이벤트: -25,000원
 
<총혜택 금액>
-31,246원
 
<할인 후 예상 결제 금액>
135,754원
 
<12월 이벤트 배지>
산타
```

기대하는 예시를 한 개만 들어서 설명했지만, 더 다양한 사례가 있을 것으로 예상됩니다.  
개발이 완료되는 대로 공유해 주시면, 비즈니스팀에서 1주일간 테스트를 진행하고 오픈할 예정입니다.  
1주일 뒤에 예정된 '12월 이벤트 플래너' 개발 회의에서 더 자세한 얘기를 해보면 좋겠습니다.

감사합니다. :)

---

## 🎯 프로그래밍 요구 사항

- Node.js 18.17.1 버전에서 실행 가능해야 한다. **Node.js 18.17.1에서 정상적으로 동작하지 않을 경우 0점 처리한다.**
- 프로그램 실행의 시작점은 `App.js`의 `run` 메서드이다. 아래와 같이 프로그램을 실행시킬 수 있어야 한다.

**예시**

```javascript
const app = new App();
app.run();
```

- `package.json`을 변경할 수 없고 외부 라이브러리(jQuery, Lodash 등)를 사용하지 않는다. 순수 Vanilla JS로만 구현한다.
- [JavaScript 코드 컨벤션](https://github.com/woowacourse/woowacourse-docs/tree/main/styleguide/javascript)을 지키면서 프로그래밍 한다
- 프로그램 종료 시 `process.exit()`를 호출하지 않는다.
- 프로그램 구현이 완료되면 `ApplicationTest`의 모든 테스트가 성공해야 한다. **테스트가 실패할 경우 0점 처리한다.**
- 프로그래밍 요구 사항에서 달리 명시하지 않는 한 파일, 패키지 이름을 수정하거나 이동하지 않는다.
- indent(인덴트, 들여쓰기) depth를 3이 넘지 않도록 구현한다. 2까지만 허용한다.
  - 예를 들어 while문 안에 if문이 있으면 들여쓰기는 2이다.
  - 힌트: indent(인덴트, 들여쓰기) depth를 줄이는 좋은 방법은 함수(또는 메서드)를 분리하면 된다.
- Jest를 이용하여 본인이 정리한 기능 목록이 정상 동작함을 테스트 코드로 확인한다.
- 함수(또는 메서드)의 길이가 15라인을 넘어가지 않도록 구현한다.
  - 함수(또는 메서드)가 한 가지 일만 하도록 최대한 작게 만들어라.
- else를 지양한다.
  - 힌트: if 조건절에서 값을 return하는 방식으로 구현하면 else를 사용하지 않아도 된다.
  - 때로는 if/else, switch문을 사용하는 것이 더 깔끔해 보일 수 있다. 어느 경우에 쓰는 것이 적절할지 스스로 고민해 본다.
- 도메인 로직에 단위 테스트를 구현해야 한다. 단, UI(Console.readLineAsync, Console.print) 로직에 대한 단위 테스트는 제외한다.
  - 핵심 로직을 구현하는 코드와 UI를 담당하는 로직을 구분한다.
- 사용자가 잘못된 값을 입력할 경우 `throw`문을 사용해 예외를 발생시킨다. 그런 다음, "[ERROR]"로 시작하는 에러 메시지를 출력하고 해당 부분부터 입력을 다시 받는다.

### 추가된 요구 사항

- 아래에 제공되는 `InputView`, `OutputView` 객체를 활용해 구현한다.
  - 입력과 출력을 담당하는 객체를 별도로 구현한다.
  - `InputView`, `OutputView`의 파일 경로는 변경할 수 있다.
  - `InputView`, `OutputView`의 메서드의 이름과 인자는 필요에 따라 추가하거나 변경할 수 있다.
  - 값 출력을 위해 필요한 메서드를 추가할 수 있다.
  ```javascript
  export default InputView = {
    async readDate() {
      const input = await Console.readLineAsync("12월 중 식당 예상 방문 날짜는 언제인가요? (숫자만 입력해 주세요!)");
      // ...
    },
    // ...
  };
  ```
  ```javascript
  export default OutputView = {
    printMenu() {
      Console.print("<주문 메뉴>");
      // ...
    },
    // ...
  };
  ```

### 라이브러리

- `@woowacourse/mission-utils`에서 제공하는 `Console` API를 사용하여 구현해야 한다.
  - 사용자의 값을 입력 받고 출력하기 위해서는 `Console.readLineAsync`, `Console.print`를 활용한다.

---

## ✏️ 과제 진행 요구 사항

- 미션은 [javascript-christmas-6](https://github.com/woowacourse-precourse/javascript-christmas-6) 저장소를 비공개 저장소로 생성해 시작한다.
- **기능을 구현하기 전 `docs/README.md`에 구현할 기능 목록을 정리**해 추가한다.
- **Git의 커밋 단위는 앞 단계에서 `docs/README.md`에 정리한 기능 목록 단위**로 추가한다.
  - [커밋 메시지 컨벤션](https://gist.github.com/stephenparish/9941e89d80e2bc58a153) 가이드를 참고해 커밋 메시지를 작성한다.
- 과제 진행 및 제출 방법은 [프리코스 과제 제출](https://docs.google.com/document/d/1cmg0VpPkuvdaetxwp4hnyyFC_G-1f2Gr8nIDYIWcKC8/edit?usp=sharing) 문서를 참고한다.
